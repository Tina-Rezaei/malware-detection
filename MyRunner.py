import random
import argparse
import numpy as np
import os
import shutil
import MyLoadData as data
from MyNet import MD
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt
from scipy.stats import mode
import time
#################### Runner ####################

result_list = []
final_accuracy_list = [] # mean accuracy during training for n iteration
final_fmeasure_list = [] # mean fmeasure during training for n iteration
final_clusterdist_list = []
final_test_acuracy_list = {'accuracy': [], 'precision': [], 'recall': [],
                                   'fmeasure': []}

start_time = 0
end_time = 0

def run_SNE(data, input_byte_num, batch_size, iteration):
    epoch = 1
    print("-------------------------")
    model = MD(data, input_byte_num, epoch, batch_size, iteration)
    results = model.train()
    final_accuracy_list.append(results[0])
    final_fmeasure_list.append(results[1])
    final_clusterdist_list.append(results[2])
    final_test_acuracy_list['accuracy'].append(results[3]['accuracy'])
    final_test_acuracy_list['precision'].append(results[3]['precision'])
    final_test_acuracy_list['recall'].append(results[3]['recall'])
    final_test_acuracy_list['fmeasure'].append(results[3]['fmeasure'])
    print(result_list)

def write_result_to_file(byte_number,batch_number,variable):
    try:
      file = open(os.path.join('/content/drive/My Drive/code/results',str(byte_number),'result.txt'), 'a+')
      file.write("result for 10 Fold" + str(batch_number) + "\n")
      file.write(str(np.mean(variable['accuracy'])) + '+' + str(np.var(variable['accuracy'])) + '\t' + str(
          np.mean(variable['precision'])) + '\t' + str(
          np.mean(variable['recall'])) + '\t' + str(
          np.mean(variable['fmeasure'])) + '+' + str(np.var(variable['fmeasure'])) + '\n')
    except:
      print("error for witing final result")


def make_plot(data, data_name, path):
    try:
        plt.plot(np.mean(data, axis=0))
        plt.savefig(path)
        plt.close()
    except:
        print('unable to plot {}'.format(data_name))

if __name__ == '__main__':


    # byte_list = [100,200,300,400,500,600,700,800, 900, 1024]
    byte_list = [324]
    batch_list = [5,10,15,20,25,30]
    iter = 1
    kf = KFold(n_splits=10)

    for batch in batch_list:
        start_time = time.time()

        for byte in byte_list:
            Data = data.Run_LoadData(byte)

            for iteration in range(iter):

                for train_index, test_index in kf.split(Data[0]['all_data']):
                    # print("TRAIN:", train_index, "TEST:", test_index)
                    X_ben_train = {'data': np.array(Data[0]['all_data'])[train_index], 'label': np.array(Data[0]['all_label'])[train_index]}
                    X_mal_train = {'data': np.array(Data[1]['all_data'])[train_index], 'label': np.array(Data[1]['all_label'])[train_index]}
                    X_ben_test = {'data': np.array(Data[0]['all_data'])[test_index], 'label': np.array(Data[0]['all_label'])[test_index]}
                    X_mal_test = {'data': np.array(Data[1]['all_data'])[test_index], 'label': np.array(Data[1]['all_label'])[test_index]}
                    run_SNE([X_ben_train, X_mal_train, X_ben_test, X_mal_test], byte, batch, iter)


            make_plot(final_accuracy_list, 'accuracy', '/content/drive/My Drive/code/' + str(byte) + '/accuracy' + str(batch) + '.png')
            make_plot(final_fmeasure_list, 'fmeasure', '/content/drive/My Drive/code/' + str(byte) + '/fmeasure' + str(batch) + '.png')
            make_plot(final_clusterdist_list, 'cluster_distance', '/content/drive/My Drive/code/' + str(byte) + '/cluster_distance' + str(batch) + '.png')

            final_accuracy_list = []
            final_fmeasure_list = []
            final_clusterdist_list = []

            write_result_to_file(byte, batch, final_test_acuracy_list)
            final_test_acuracy_list = {'accuracy': [], 'precision': [], 'recall': [],
                                       'fmeasure': []}

            end_time = time.time()
            print(str(end_time - start_time))


